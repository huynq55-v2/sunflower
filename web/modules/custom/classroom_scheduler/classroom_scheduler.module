<?php

use Drupal\node\NodeInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\Entity\Node;

/**
 * Implements hook_node_update().
 */
function classroom_scheduler_node_update(NodeInterface $node) {
  if ($node->bundle() !== 'lesson') {
    return;
  }

  // Ghi log ƒë·ªÉ x√°c nh·∫≠n hook ƒë∆∞·ª£c g·ªçi cho ƒë√∫ng bu·ªïi h·ªçc
  \Drupal::logger('classroom_scheduler')->notice('hook_node_update triggered for lesson: @label (ID: @id)', [
    '@label' => $node->label(),
    '@id' => $node->id()
  ]);

  // Ki·ªÉm tra xem node->original c√≥ t·ªìn t·∫°i kh√¥ng
  if (!isset($node->original)) {
    \Drupal::logger('classroom_scheduler')->warning('Node original property not found on update.');
    return;
  }

  $old_value = $node->original->get('field_is_happened')->value ?? 0;
  $new_value = $node->get('field_is_happened')->value ?? 0;

  // Ghi log gi√° tr·ªã c≈© v√† m·ªõi
  \Drupal::logger('classroom_scheduler')->notice('field_is_happened changed from @old to @new.', [
    '@old' => $old_value,
    '@new' => $new_value
  ]);

  // Ch·ªâ th·ª±c hi·ªán khi c√≥ s·ª± thay ƒë·ªïi gi√° tr·ªã
  if ($old_value == $new_value) {
    return;
  }

  /** @var \Drupal\node\NodeInterface $classroom */
  $classroom = $node->get('field_classroom')->entity;
  if (!$classroom) {
    $message = 'Kh√¥ng t√¨m th·∫•y l·ªõp h·ªçc ƒë∆∞·ª£c tham chi·∫øu t·ª´ bu·ªïi h·ªçc.';
    \Drupal::messenger()->addError($message);
    \Drupal::logger('classroom_scheduler')->error($message);
    return;
  }
  
  // Ghi log th√¥ng tin l·ªõp h·ªçc
  \Drupal::logger('classroom_scheduler')->notice('Found classroom: @label', ['@label' => $classroom->label()]);


  $fee = (int) $classroom->get('field_fee')->value;
  $teacher = $classroom->get('field_teacher')->entity ?? NULL;
  $students = $node->get('field_student_list')->referencedEntities();

  if ($fee <= 0 || !$teacher) {
    $message = 'L·ªõp h·ªçc (@class) ch∆∞a c√≥ h·ªçc ph√≠ (Fee: @fee) ho·∫∑c gi√°o vi√™n (Teacher: @teacher). D·ª´ng t·∫°o giao d·ªãch.';
    \Drupal::messenger()->addError(t('L·ªõp h·ªçc ch∆∞a c√≥ h·ªçc ph√≠ ho·∫∑c gi√°o vi√™n.'));
    \Drupal::logger('classroom_scheduler')->warning($message, [
      '@class' => $classroom->label(),
      '@fee' => $fee,
      '@teacher' => $teacher ? $teacher->label() : 'NULL',
    ]);
    return;
  }
  
  $lesson_label = $node->label();
  $study_time = $node->get('field_study_time')->value;
  $timestamp = $study_time ? strtotime($study_time) : time();

  // ========== CASE 1: "ch∆∞a h·ªçc" -> "ƒë√£ h·ªçc" ==========
  if ($old_value == 0 && $new_value == 1) {
    \Drupal::logger('classroom_scheduler')->notice('CASE 1: "ch∆∞a h·ªçc" -> "ƒë√£ h·ªçc". Starting to create transactions.');

    foreach ($students as $student) {
      $account = sunflower_get_account_for($student->id(), $classroom->id());
      if (!$account) {
        \Drupal::logger('classroom_scheduler')->warning('Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n cho h·ªçc sinh @student trong l·ªõp @class. B·ªè qua.', [
          '@student' => $student->label(),
          '@class' => $classroom->label(),
        ]);
        continue;
      }
      \Drupal::logger('classroom_scheduler')->notice('Processing student: @student, account: @account', [
        '@student' => $student->label(),
        '@account' => $account->label(),
      ]);

      $fee_amount = $fee;

      $txn = Node::create([
        'type' => 'transaction',
        'title' => "H·ªçc ph√≠ {$lesson_label} - {$student->label()}" .
          ($student->hasField('field_full_name') && !$student->get('field_full_name')->isEmpty()
            ? ' (' . $student->get('field_full_name')->value . ')'
            : ''),
        'field_lesson' => ['target_id' => $node->id()],
        'field_account' => ['target_id' => $account->id()],
        'field_amount' => $fee_amount,
        'field_type' => 'debit',
        'field_date' => $study_time ? substr($study_time, 0, 10) : date('Y-m-d'),
      ]);
      $txn->setCreatedTime($timestamp);
      $txn->save();

      \Drupal::logger('classroom_scheduler')->notice('CREATED transaction node @id for student @student.', [
        '@id' => $txn->id(),
        '@student' => $student->label(),
      ]);

      sunflower_update_account_transactions($account, $txn);

      // KH√îNG c·∫ßn g·ªçi update balance ·ªü ƒë√¢y n·ªØa. Hook entity_insert/update c·ªßa `sunflower_finance` s·∫Ω t·ª± ƒë·ªông l√†m vi·ªác n√†y.
      // \Drupal::service('sunflower_finance.account_balance_manager')->updateAccountBalance($account->id());
    }

    // üß© Gi√°o vi√™n
    $teacher_account = sunflower_get_account_for($teacher->id(), $classroom->id());
    if ($teacher_account) {
      $total_credit = count($students) * $fee;

      $txn_teacher = Node::create([
        'type' => 'transaction',
        'title' => "Thu nh·∫≠p {$lesson_label} - {$teacher->label()}" .
          ($teacher->hasField('field_full_name') && !$teacher->get('field_full_name')->isEmpty()
            ? ' (' . $teacher->get('field_full_name')->value . ')'
            : ''),
        'field_lesson' => ['target_id' => $node->id()],
        'field_account' => ['target_id' => $teacher_account->id()],
        'field_amount' => $total_credit,
        'field_type' => 'credit',
        'field_date' => $study_time ? substr($study_time, 0, 10) : date('Y-m-d'),
      ]);
      $txn_teacher->setCreatedTime($timestamp);
      $txn_teacher->save();
      
      \Drupal::logger('classroom_scheduler')->notice('CREATED transaction node @id for teacher @teacher.', [
        '@id' => $txn_teacher->id(),
        '@teacher' => $teacher->label(),
      ]);

      sunflower_update_account_transactions($teacher_account, $txn_teacher);
      // KH√îNG c·∫ßn g·ªçi update balance ·ªü ƒë√¢y n·ªØa.
      // \Drupal::service('sunflower_finance.account_balance_manager')->updateAccountBalance($teacher_account->id());
    }

    \Drupal::messenger()->addStatus("‚úÖ ƒê√£ t·∫°o giao d·ªãch cho bu·ªïi h·ªçc {$lesson_label}.");
  }

  // ========== CASE 2: "ƒë√£ h·ªçc" -> "ch∆∞a h·ªçc" ==========
  if ($old_value == 1 && $new_value == 0) {
    \Drupal::logger('classroom_scheduler')->notice('CASE 2: "ƒë√£ h·ªçc" -> "ch∆∞a h·ªçc". Starting to delete transactions.');
    
    // ... (ph·∫ßn code case 2 c·ªßa b·∫°n) ...
    $query = \Drupal::entityQuery('node')
      ->condition('type', 'transaction')
      ->condition('field_lesson', $node->id())
      ->accessCheck(FALSE);
    $txn_ids = $query->execute();

    if ($txn_ids) {
      $txns = Node::loadMultiple($txn_ids);
      $affected_accounts = [];

      foreach ($txns as $txn) {
        $account = $txn->get('field_account')->entity;
        if (!$account) continue;

        // L∆∞u ID t√†i kho·∫£n ƒë·ªÉ t√≠nh to√°n l·∫°i sau khi x√≥a h·∫øt giao d·ªãch
        $affected_accounts[$account->id()] = $account;

        // X√≥a transaction kh·ªèi field_transactions tr∆∞·ªõc
        sunflower_remove_transaction_from_account($account, $txn);

        $txn->delete(); // <- Hook entity_delete c·ªßa `sunflower_finance` s·∫Ω ƒë∆∞·ª£c g·ªçi ·ªü ƒë√¢y.
        
        \Drupal::logger('classroom_scheduler')->notice('DELETED transaction node for account @account.', [
            '@account' => $account->label(),
        ]);
      }
      
      // Hook entity_delete ƒë√£ lo vi·ªác c·∫≠p nh·∫≠t balance r·ªìi, n√™n v√≤ng l·∫∑p n√†y c√≥ th·ªÉ kh√¥ng c·∫ßn thi·∫øt n·ªØa
      // Nh∆∞ng ƒë·ªÉ cho ch·∫Øc ch·∫Øn, b·∫°n c√≥ th·ªÉ g·ªçi l·∫°i 1 l·∫ßn sau khi m·ªçi th·ª© ƒë√£ x√≥a xong.
      foreach ($affected_accounts as $acc) {
         \Drupal::service('sunflower_finance.account_balance_manager')->updateAccountBalance($acc->id());
      }

      \Drupal::messenger()->addStatus("‚Ü©Ô∏è ƒê√£ x√≥a giao d·ªãch c·ªßa bu·ªïi h·ªçc v√† c·∫≠p nh·∫≠t l·∫°i l·ªãch s·ª≠ t√†i kho·∫£n.");
    }
  }
}

/**
 * Hook ch·∫°y tr∆∞·ªõc khi node ƒë∆∞·ª£c l∆∞u.
 * M·ª•c ti√™u: ch·∫∑n revert n·∫øu c√≥ giao d·ªãch ƒë√£ t√≠nh ti·ªÅn.
 */
function classroom_scheduler_node_presave(NodeInterface $node) {
  if ($node->bundle() !== 'lesson' || !$node->original) {
    return;
  }

  $old_value = $node->original->get('field_is_happened')->value ?? 0;
  $new_value = $node->get('field_is_happened')->value ?? 0;

  if ($old_value == 1 && $new_value == 0) {
    $lesson_label = $node->label();

    // T√¨m t·∫•t c·∫£ giao d·ªãch c·ªßa bu·ªïi h·ªçc n√†y.
    $query = \Drupal::entityQuery('node')
      ->condition('type', 'transaction')
      ->condition('field_lesson', $node->id())
      ->accessCheck(FALSE);
    $txn_ids = $query->execute();

    if (!empty($txn_ids)) {
      $paid_txn_ids = \Drupal::entityQuery('node')
        ->condition('nid', $txn_ids, 'IN')
        ->condition('field_has_calculated_money', TRUE)
        ->accessCheck(FALSE)
        ->execute();

      if (!empty($paid_txn_ids)) {
        \Drupal::messenger()->addError("‚ùå Bu·ªïi h·ªçc {$lesson_label} kh√¥ng th·ªÉ revert v√¨ c√≥ giao d·ªãch ƒë√£ t√≠nh ti·ªÅn cho ng∆∞·ªùi d√πng.");
        // Gi·ªØ nguy√™n tr·∫°ng th√°i c≈© ‚Üí kh√¥ng revert ƒë∆∞·ª£c.
        $node->set('field_is_happened', 1);
      }
    }
  }
}

/**
 * Helper: L·∫•y Account node cho user + classroom.
 *
 * @param int $uid
 * @param int $classroom_id
 * @return \Drupal\node\Entity\Node|null
 */
function sunflower_get_account_for($uid, $classroom_id) {
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'account')
    ->condition('field_student', $uid)
    ->condition('field_classroom', $classroom_id)
    ->accessCheck(FALSE);

  $ids = $query->execute();
  if (empty($ids)) return NULL;

  $account_id = reset($ids);
  return Node::load($account_id);
}

/**
 * Implements hook_form_alter().
 */
function classroom_scheduler_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id === 'node_lesson_form') {
    $request = \Drupal::request();
    $classroom_id = $request->query->get('field_classroom');

    // üß© N·∫øu t·∫°o bu·ªïi h·ªçc m·ªõi t·ª´ ƒë∆∞·ªùng d·∫´n c√≥ classroom_id
    if ($classroom_id && ($classroom = Node::load($classroom_id))) {
      // ‚úÖ ƒêi·ªÅn s·∫µn classroom
      $form['field_classroom']['widget'][0]['target_id']['#default_value'] = $classroom;
      $form['field_classroom']['widget'][0]['target_id']['#disabled'] = TRUE;
      $form['field_classroom']['widget'][0]['target_id']['#attributes']['readonly'] = 'readonly';

      // ‚úÖ Clone danh s√°ch h·ªçc sinh t·ª´ classroom sang lesson
      if ($classroom->hasField('field_student_list')) {
        $student_refs = [];
        foreach ($classroom->get('field_student_list')->referencedEntities() as $student) {
          $student_refs[] = ['target_id' => $student->id()];
        }
        if (!empty($student_refs)) {
          $form['field_student_list']['widget']['#default_value'] = $classroom->get('field_student_list')->referencedEntities();
        }
      }

      // ‚úÖ G·ª£i √Ω t√™n bu·ªïi h·ªçc
      $query = \Drupal::entityTypeManager()->getStorage('node')->getQuery();
      $query->condition('type', 'lesson');
      $query->condition('field_classroom', $classroom_id);
      $query->accessCheck(FALSE);
      $count = $query->count()->execute();

      $next_number = $count + 1;
      $title_suggest = $classroom->label() . ' bu·ªïi ' . str_pad($next_number, 3, '0', STR_PAD_LEFT);
      $form['title']['widget'][0]['value']['#default_value'] = $title_suggest;
    }
  }
}

/**
 * Recalculate account balance.
 *
 * @param int|\Drupal\node\NodeInterface $account
 *   Account node or nid.
 * @param bool $only_unpaid
 *   If TRUE, include only transactions where field_has_calculated_money is not set or FALSE.
 *   If FALSE, include all transactions.
 */
function sunflower_recalculate_account_balance($account, $only_unpaid = TRUE) {
  static $running_accounts = [];

  // Load node if numeric.
  if (is_numeric($account)) {
    $account = Node::load((int) $account);
  }

  if (!$account instanceof NodeInterface || $account->bundle() !== 'account') {
    \Drupal::logger('sunflower')->error('sunflower_recalculate_account_balance() called with invalid account.');
    return;
  }

  $account_id = $account->id();

  // Prevent recursion for the same account in one request.
  if (!empty($running_accounts[$account_id])) {
    \Drupal::logger('sunflower')->debug('Skip recursive recalc for account @id', ['@id' => $account_id]);
    return;
  }
  $running_accounts[$account_id] = TRUE;

  try {
    \Drupal::logger('sunflower')->notice('Start recalculating account @id (@title) ‚Äî only_unpaid: @u', [
      '@id' => $account_id,
      '@title' => $account->label(),
      '@u' => $only_unpaid ? '1' : '0',
    ]);

    // Build query for transaction nodes related to this account.
    $query = \Drupal::entityQuery('node')
      ->condition('type', ['transaction', 'transaction_log'], 'IN')
      ->condition('field_account', $account_id)
      ->accessCheck(FALSE);

    // If only_unpaid requested, add condition: either field doesn't exist or equals 0.
    if ($only_unpaid) {
      $group = $query->orConditionGroup()
        ->notExists('field_has_calculated_money')
        ->condition('field_has_calculated_money', 0);
      $query->condition($group);
    }

    $txn_ids = $query->execute();

    $transactions = Node::loadMultiple($txn_ids);

    // Build sortable list with effective timestamps.
    $items = [];
    foreach ($transactions as $txn) {
      $effective_ts = NULL;

      // transaction -> prefer lesson.field_study_time (date only => start of day)
      if ($txn->bundle() === 'transaction' && $txn->hasField('field_lesson') && !$txn->get('field_lesson')->isEmpty()) {
        $lesson = $txn->get('field_lesson')->entity;
        if ($lesson && $lesson->hasField('field_study_time') && !$lesson->get('field_study_time')->isEmpty()) {
          $val = $lesson->get('field_study_time')->value;
          if ($val) {
            $effective_ts = strtotime($val . ' 00:00:00');
          }
        }
      }

      // transaction_log or fallback -> field_date (datetime) if present
      if ($effective_ts === NULL && $txn->hasField('field_date') && !$txn->get('field_date')->isEmpty()) {
        $val = $txn->get('field_date')->value;
        if ($val) {
          $effective_ts = strtotime($val);
        }
      }

      // fallback -> created time
      if ($effective_ts === NULL) {
        $effective_ts = (int) $txn->getCreatedTime();
      }

      $items[] = [
        'txn' => $txn,
        'eff' => (int) $effective_ts,
        'created' => (int) $txn->getCreatedTime(),
        'nid' => (int) $txn->id(),
      ];
    }

    // Sort: effective asc, created asc, nid asc.
    usort($items, function ($a, $b) {
      if ($a['eff'] !== $b['eff']) {
        return $a['eff'] <=> $b['eff'];
      }
      if ($a['created'] !== $b['created']) {
        return $a['created'] <=> $b['created'];
      }
      return $a['nid'] <=> $b['nid'];
    });

    // Compute running balance.
    $running_balance = 0;
    foreach ($items as $it) {
      /** @var \Drupal\node\Entity\Node $t */
      $t = $it['txn'];
      $amount = 0.0;
      if ($t->hasField('field_amount') && !$t->get('field_amount')->isEmpty()) {
        $amount = (float) $t->get('field_amount')->value;
      }

      if ($t->bundle() === 'transaction') {
        // debit => subtract, credit => add
        $type = $t->hasField('field_type') ? $t->get('field_type')->value : NULL;
        if ($type === 'debit') {
          $running_balance -= $amount;
        } elseif ($type === 'credit') {
          $running_balance += $amount;
        } else {
          // if missing, assume debit? we will log and skip change
          \Drupal::logger('sunflower')->warning('Transaction @id missing field_type; skipping sign', ['@id' => $t->id()]);
          $running_balance += 0;
        }
      } else {
        // transaction_log: add amount directly (amount may be negative for deduction)
        $running_balance += $amount;
      }

      \Drupal::logger('sunflower')->debug('Txn @id (@bundle) eff=@time amount=@amt => running=@bal', [
        '@id' => $t->id(),
        '@bundle' => $t->bundle(),
        '@time' => date('Y-m-d H:i:s', $it['eff']),
        '@amt' => $amount,
        '@bal' => (int) $running_balance,
      ]);
    }

    $account->save();

    \Drupal::logger('sunflower')->info('Recalc finished for account @id final balance=@bal (only_unpaid=@u)', [
      '@id' => $account_id,
      '@bal' => (int) $running_balance,
      '@u' => $only_unpaid ? '1' : '0',
    ]);
  }
  catch (\Throwable $e) {
    \Drupal::logger('sunflower')->error('Exception in sunflower_recalculate_account_balance(@id): @m', [
      '@id' => $account_id,
      '@m' => $e->getMessage(),
    ]);
  }
  finally {
    $running_accounts[$account_id] = FALSE;
  }
}

/**
 * Th√™m 1 transaction v√†o danh s√°ch field_transactions c·ªßa account theo ƒë√∫ng th·ª© t·ª± th·ªùi gian.
 */
function sunflower_update_account_transactions(Node $account, Node $txn) {
  $refs = $account->get('field_transactions')->referencedEntities();
  $refs[] = $txn;

  // S·∫Øp x·∫øp l·∫°i theo th·ªùi gian hi·ªáu l·ª±c
  usort($refs, function($a, $b) {
    $timeA = sunflower_get_transaction_timestamp($a);
    $timeB = sunflower_get_transaction_timestamp($b);
    return $timeA <=> $timeB;
  });

  $account->set('field_transactions', array_map(fn($t) => ['target_id' => $t->id()], $refs));
  $account->save();
}

/**
 * X√≥a transaction kh·ªèi danh s√°ch field_transactions c·ªßa account.
 */
function sunflower_remove_transaction_from_account(Node $account, Node $txn) {
  $items = $account->get('field_transactions')->getValue();
  $new_items = array_filter($items, fn($i) => $i['target_id'] != $txn->id());
  $account->set('field_transactions', array_values($new_items));
  $account->save();
}

/**
 * X√°c ƒë·ªãnh timestamp th·ª±c c·ªßa 1 transaction (d·ª±a v√†o date/lesson/study_time).
 */
function sunflower_get_transaction_timestamp(Node $txn) {
  // ∆Øu ti√™n field_date
  if ($txn->hasField('field_date') && !$txn->get('field_date')->isEmpty()) {
    return strtotime($txn->get('field_date')->value);
  }

  // N·∫øu c√≥ bu·ªïi h·ªçc, l·∫•y field_study_time
  if ($txn->hasField('field_lesson') && !$txn->get('field_lesson')->isEmpty()) {
    $lesson = $txn->get('field_lesson')->entity;
    if ($lesson && !$lesson->get('field_study_time')->isEmpty()) {
      return strtotime($lesson->get('field_study_time')->value);
    }
  }

  // Fallback: th·ªùi gian t·∫°o node
  return $txn->getCreatedTime();
}
